CREATE TABLE Tasks (
	ID SERIAL PRIMARY KEY,
	position INT NOT NULL,
	description TEXT NOT NULL,
	assignedDate VARCHAR(8) NOT NULL,
	state INT NOT NULL,
	UNIQUE(position,assignedDate),
	CHECK (state>0 AND state<4)
);

CREATE TABLE TimelineTasks (
	ID SERIAL PRIMARY KEY,
	position INT NOT NULL,
	description TEXT NOT NULL,
	startDate VARCHAR(8) NOT NULL,
    endDate VARCHAR(8) NOT NULL,
	state INT NOT NULL,
	project TEXT NOT NULL,
	UNIQUE(position),
	CHECK (state>0 AND state<4)
);


CREATE TABLE Notes (
	ID SERIAL PRIMARY KEY,
	position INT NOT NULL,
	description TEXT NOT NULL,
	UNIQUE(position)
);

CREATE TABLE Projects (
	name TEXT PRIMARY KEY,
	active BOOLEAN NOT NULL
);

-- A function that computes the next available position
CREATE FUNCTION next(date VARCHAR(8)) RETURNS INT AS $$
  SELECT COALESCE(MAX(position),0)+1 FROM Tasks WHERE assignedDate=date
$$ LANGUAGE SQL;


-- A function to adjust positions after someone is removed from the list
CREATE OR REPLACE FUNCTION compact() RETURNS TRIGGER AS $$
BEGIN
  UPDATE Tasks SET position = position-1 WHERE position>=OLD.position AND assignedDate=OLD.assignedDate;
  RETURN NULL;
END
$$ LANGUAGE plpgsql;


CREATE TRIGGER compact AFTER DELETE ON Tasks
  FOR EACH ROW EXECUTE FUNCTION compact();



CREATE OR REPLACE FUNCTION addproject()
  RETURNS trigger AS
$$
BEGIN
	INSERT INTO Projects
    SELECT project, true
    FROM TimelineTasks
    WHERE project NOT IN(SELECT name FROM Projects);
    RETURN NULL;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER addproject AFTER INSERT ON TimelineTasks
EXECUTE FUNCTION addproject();

CREATE OR REPLACE FUNCTION removeproject()
  RETURNS trigger AS
$$
BEGIN
    DELETE FROM Projects WHERE (name NOT IN (SELECT project FROM TimelineTasks));
    RETURN NULL;

END
$$ LANGUAGE plpgsql;

CREATE TRIGGER removeproject AFTER DELETE ON TimelineTasks
EXECUTE FUNCTION removeproject();


